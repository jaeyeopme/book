# Chapter 2 - 단위 테스트란 무엇인가

단위 테스트의 정의는 많은 뉘앙스가 있다. 이러한 뉘앙스 때문에 해석의 차이가 생겼고, 단위 테스트에 접근하는 방법이 '고전파', '런던파' 두 가지 견해로 나뉘었다. '고전파'는 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식이기 때문에 '고전'이라고 한다. '런던파'는 런던의 프로그래밍 커뮤니티에서 시작되었기 때문에 '런던'이라고 한다.

## 2.1 '단위 테스트'의 정의

**단위 테스트의 가장 중요한 세 가지 속성**

* 작은 코드 조각(단위라고도 함)을 검증한다.
* 빠르게 수행한다.
* **격리된 방식**으로 처리하는 자동화된 테스트다.

테스트의 실행 속도는 주관적인 논쟁이 생길 수 있지만, 그리 중요하지 않다. 두 가지 견해로 나뉘었던 이유는 세 번째 속성이다. 두 분파간의 모든 차이는 격리가 정확히 무엇인지에 대한 의견 차이 하나로 시작됐다.

### 2.1.1 격리 문제에 대한 런던파의 접근

런던파의 격리된 방식이란 테스트 대상 시스템을 협력자에게서 격리하는 것을 말한다. 하나의 클래스가 의존하고 있는 모든 의존성을 테스트 더블로 대체해야 한다. 이런 식의 동작은 테스트 대상 클래스에만 집중할 수 있게 한다.

> 테스트 더블이란 실행과 관련 없이 모든 종류의 가짜 의존성을 말하는 포괄적인 용어이다.

**모든 의존성이 테스트 더블인 경우의 이점**

* 테스트가 실패하면 모든 의존성은 테스트 더블이기 때문에 실패 부분을 확실히 알 수 있다.
* 객체 그래프를 분할할 수 있다. 의존성이 많아질수록 그래프는 복잡해진다. 이러한 코드를 테스트하는 것은 테스트 더블 없이는 어렵다.
* 프로젝트 전반적으로 한 번에 한 클래스만 테스트 하라는 지침을 도입하면 테스트 스위트의 구조가 간단해진다.

고전 스타일은 테스트 협력자를 대체하지 않고 실제 인스턴스를 사용한다. 테스트 협력자의 상태를 검증하여 테스트 대상과 테스트 협력자 둘 다 효과적으로 검증한다. 그러나 테스트 협력자 내부에 버그가 있다면 테스트에 실패할 수 있다.

런던 스타일은 테스트 협력자를 실제 인스턴스를 생성하지 않고 Mock 프레임워크를 사용해 목으로 대체한다. 인터페이스로 된 목을 만들고 요청에 대한 응답을 직접 정의한다. 목은 요구하는 응답 방식으로 요청에 응답한다.

고전 스타일은 테스트 협력자의 상태를 검증했다. 하지만 런던 스타일은 테스트 협력자의 상태가 아닌 테스트 대상과의 상호 작용 즉, 테스트 대상이 테스트 협력자를 올바르게 호출 했는지를 검증한다.

> 목이란 테스트 더블에서 말하는 가짜 의존성의 한 종류이다.

### 2.1.2 격리 문제에 대한 고전파의 접근

고전파의 격리된 방식이란 코드를 꼭 격리하는 방식은 아니며 대신 단위 테스트를 서로 격리해서 실행하는 것을 말한다. 이는 어떤 순서(병렬이나 순차 등)든 가장 적합한 방식으로 실행할 수 있으며 서로 결과에 영향을 미치지 않는다.

각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태(_공유 의존성_)가 아니라면 여러 클래스를 한번에 테스트해도 괜찮다. 하지만 공유 상태라면 실행 컨텍스트에 영향을 주는 테스트 간섭이 생긴다.

> 공유 의존성이란 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다.

보통 테스트 간의 공유 의존성에 대해서만 테스트 더블을 사용한다.

> 프로세스 외부 의존성이란 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 메모리에 없는 데이터에 대한 프록시이다. 대부분 공유 의존성에 해당하지만 TestContainers 처럼 각 테스트 마다 새로운 인스턴스를 사용해 프로세스 외부이면서 공유하지 않는 의존성으로 서로 결과에 영향을 미치지 않을 수 있다.

공유 의존성은 테스트 대상 클래스가 아닌 단위 테스트 간에 공유한다. 코드베이스에서 싱글턴 인스턴스를 사용하더라도 각 테스트에서 새 인스턴스를 만들 수 있기만하면 이는 공유되지 않는다. 이는 _비공개 의존성_이다.

> 비공개 의존성이란 공유하지 않는 의존성이다.

테스트 스위트 전체에서 단일 인스턴스를 유지할 필요는 없지만, 공유 의존성은 테스트 간에 공유되거나 테스트 대역으로 대체돼야 한다.

> 휘발성 의존성이란 개발자에게 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구하거나, 난수 생성과 같은 비결정적 동작을 포함하는 의존성이다.

공유 의존성은 거의 항상 실행 프로세스 외부에 있기 때문에, 보통 그 경계를 넘지 않는 비공개 의존성보다 호출이 더 오래 걸린다. 단위 테스트는 빠르게 수행해야하기 때문에 공유 의존성을 가진 테스트는 통합 테스트 영역으로 넘어간다.

단위가 클래스에 국한될 필요없이 공유 의존성이 없다면 여러 클래스를 묶어 단위 테스트할 수 있다.

## 2.2 단위 테스트의 런던파와 고전파

|        | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ------ | ----------- | ---------------------------- | -------------------------- |
| 런던파 | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 클래스 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |

### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

```cs
[Fact]
public void Purchase_fails_when_not_enough_inventory()
{
    // Assert
    var storeMock = new Mock<IStore>();
    storeMock
        .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
        .Returns(false);
    var customer = new Customer;
    
    // Act
    bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);
    
    // Assert
    Assert.False(success);
    storeMock.Verify(
        x => x.RemoveInventory(Product.Shampoo, 5),
        Times.Never;
    )
}
```

런던파는 테스트에서는 불변 객체는 그대로 사용할 수 있도록 한다. 불변 객체의 주요 특징은 각각의 정체성이 없다는 것으로 즉, 내용에 의해서만 식별되기 때문에 인스턴스를 서로 바꿔 사용할 수 있다.

정리하자면 데이터베이스는 **공유 의존성**이며, 내부 상태(테스트 더블로 대체되지 않은)는 모든 자동화된 테스트에서 공유한다. 비공개 의존성은 변경 가능하거나 불변일 수 있으며 `Store` 는 **변경 가능한 비공개 의존성**이고,  `Product` 는 **불변인 비공개 의존성**(값 객체)이다. 협력자는 공유하거나 변경 가능한 의존성이며, `Product` 는 의존성이지만 협력자는 아니다.

고전파에서는 공유 의존성을 테스트 더블로 교체하고, 런던파에서는 변경 가능한 비공개 의존성도 테스트 더블로 교체할 수 있다.

프로세스 외부 의존성은 변경하는 기능을 노출하지 않는 한 공유 의존성이 아니다. 이러한 의존성은 휘발성이고 애플리케이션의 경계를 벗어나지만, 테스트가 반환하는 데이터에 **영향**을 미치지 않기 때문에 공유가 아니다. 하지만 이런 의존성을 테스트 범위에 포함해야 하는 것은 아니며 충분히 빠르고 연결이 안정적이라면 테스트에서 그대로 사용하는 것도 괜찮다.

실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다. 프로세스 내부에 있으면 별도의 인스턴스를 쉽게 제공할 수 있기 때문에 공유할 필요가 없다. 마찬가지로 프로세스 외부이며 공유되지 않는 의존성도 거의 없다. 대부분 변경 가능하며 테스트로 수정될 수 있다.

## 2.3 고전파와 런던파의 비교

고전파와 런던파의 주요 차이는 격리 문제를 어떻게 다루는지에 있다. 이는 테스트해야 할 단위의 처리와 의존성 취급에 대한 방법으로 이어진다.

런던파의 목을 사용하는 테스트는 고전적인 테스트보다 불안정한 경향(취약성)이 있기 때문에 고전파가 고품질 테스트를 만들고 궁극적인 목표인 프로젝트의 지속 가능한 성장을 달성하는데 더 적합하다. 

**런던파의 이점**

* 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
* 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문이다.
* 테스트가 실패하면 어떤 기능이 실패했는지 확실하게 알 수 있다. 협력자가 없으면 테스트 대상 클래스만 의심하면 된다. 하지만 테스트 대상 시스템이 값 객체를 사용하는 경우 값 객체의 변경에 의해 테스트가 실패할 수 있다. 그러나 테스트의 다른 의존성을 모두 제거했기 때문에 이런 경우는 흔하지 않다.

### 2.3.1 한 번에 한 클래스만 테스트하기

런던파는 클래스를 단위로 간주하며, 객체지향 프로그래밍 경력을 가진 개발자들은 보통 클래스를 코드 베이스의 기초에 위치한 원자 빌딩 블록으로 간주하기 때문에 테스트에서도 클래스를 검증할 원자 단위로 취급한다.

테스트는 코드의 단위가 아닌 동작의 단위를 검증해야 하며 단일 동작 단위를 검증하는 한 좋은 테스트다. 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 이것은 일반 사람들에게 응집도가 높고 의미가 있어야 한다.

**응집도가 높은 경우**

> 우리집 강아지를 부르면, 바로 나에게 온다.

**응집도가 낮은 경우**

> 우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다...

실제 동작(개가 주인에게 오는 것) 대신 개별 클래스(다리, 머리, 꼬리)를 목표로 할 때 테스트가 이렇게 보이기 시작한다. 동작을 내부적인 세부구현과 구분 지어야 한다.

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

실제 협력자를 대신해 목을 사용하면 쉽게 테스트할 수 있다. 이는 복잡한 의존성 그래프 같은 단위 테스트에서 준비해야 할 작업량을 크게 줄여준다. 하지만 복잡한 의존성 그래프를 테스트할 방법 대신 이러한 그래프를 갖지 않는 데 집중해야 한다. 테스트 더블을 사용해도 문제 해결이 아니라 숨길 뿐이다.

### 2.3.3 버그 위치 정확히 찾아내기

버그가 생기면 보통 SUT에 버그가 포함된 테스트만 실패한다. 하지만 테스트를 정기적으로 실행한다면 바로 마지막에 수정한 것이 버그의 원인일 것이기 때문에 큰 문제는 아니다.

### 2.3.4 고전파와 런던파 사이의 다른 차이점

런던파의 TDD 설계 방식은 하향식이며, 목을 통해 구현을 나중으로 미루기 때문에 테스트 대상 클레스에만 집중할 수 있다. 

고전파의 TDD 설계 방식은 상향식이며, 일반적으로 도메인 모델부터 시작해서 사용자가 사용할 수 있을 때 까지 계층을 쌓아올린다.

런던 스타일의 가장 큰 문제는 목의 무분별한 사용으로 인해 SUT의 구현 세부 사항과 자주 결합되는 **과잉 명세**이다.

## 2.4 두 분파의 통합 테스트

**고전파의 단위 테스트 기준**

* 단일 동작 단위를 검증한다.
* 빠르게 수행한다.
* 다른 테스트와 별도로 처리한다.

통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트다.

* 단일 동작 단위를 검증한다.
    * 실행 속도의 최적화 또는 다른 팀이 개발한 모듈을 테스트하는 등 둘 이상의 동작 단위를 검증한다. 
* 빠르게 수행한다.
    * 프로세스 외부 의존성 접근은 느리다.
* 다른 테스트와 별도로 처리한다.
    * 병렬 테스트를 위한 공유 의존성의 간섭을 막기 위해 여러 테스트를 순차적으로 실행한다.

통합 테스트는 통상적으로 외부 의존성이 필요하기 때문에 사실 세가지 다 충족하지 못한다. 하지만 시스템 전체를 검증하기 때문에 시스템 품질 기여에 중요한 역할을 한다.

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

통합 테스트의 일부이며 둘의 차이점은 일반적으로 통합 테스트는 (DB 같은 자동으로 설정하기 쉬운)의존성이 한 두개인 반면 E2E 테스트는 외부 의존성을 전부 또는 대다수를 가지고 동작한다.

최종 사용자의 관점에서 검증하는 과정이며, 테스트 대상에 대한 제어 권한이 없기 때문에 특수 테스트 계정을 설정하는 등 유지보수 비용이 가장 많이 들기 때문에 CI 과정 후반부에 실행하는게 좋다.

하지만 모든 의존성을 처리하지 못할 수 있고, 의존성의 테스트 버전이 없거나, 필요한 상태로 가져오지 못할 수 있기 때문에 여전히 테스트 더블을 사용할 필요가 있다.