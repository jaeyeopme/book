# Chapter 4 - 좋은 단위 테스트의 4대 요소

다음은 1장에서 본 좋은 단위 테스트 스위트의 특성이다.

* 개발 주기에 통합돼 있다. 테스트에만 가치 있다.
* 코드베이스의 가장 중요하 부분만을 대상으로 한다. 도메인 모델을 다른 것과 구별하는 것은 중요하다.
* 최소한의 유지비로 최대 가치를 끌어낸다. 이것을 달성하려면 두 가지를 먼저 달성해야 한다.
  * 가치 있는 테스트 식별
  * 가치 있는 테스트 작성

이 장에서는 가치 있는 테스트를 식별하는 방법을 알아본다.

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

좋은 단위 테스트의 특성에는 다음 네가지 특성이 있다.

* 회귀 방지
* 리팩터링 내성
* 빠른 피드백
* 유지 보수성

### 4.1.1 첫 번째 요소: 회귀 방지

**회귀**란 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우다. 최악인 것은 개발할 기능이 많을수록 고장 날 가능성이 높다는 점이다. 코드는 자산이 아니라 **책임**이며, 코드베이스가 커질수록 잠재적인 버그에 더 많이 **노출**된다. 그래서 회귀에 대한 **보호**를 개발하는 것은 중요하다. 회귀 방지 지표에 대한 테스트 점수를 평가하려면 다음과 같은 사항을 고려해야 한다.

* 테스트 중에 실행되는 코드의 양
* 코드 복잡도
* 코드의 도메인 유의성

일반적으로 실행되는 코드가 **많을수록** 회귀의 가능성은 높다. 코드가 예외를 발생시키지 않고 실행된다는 것을 아는 데 도움은 되지만, 코드가 생성하는 **결과**가 유효한지도 확인해야 한다. 지표를 극대화하려면 **가능한 한 많은** 코드를 **실행**하는 것을 목표로 해야 한다.

코드 복잡도와 도메인 유의성도 중요하다. 비즈니스에 중요한 기능에서 발생한 버그가 **가장 큰** 피해를 입힌다. 반면 단순한 코드를 테스트 하는 것은 짧고, 비즈니스 로직을 많이 담고 있지도 않기 때문에 **테스트 가치**가 거의 없으며, 회귀 가능성도 낮다.

작성한 코드 외에 라이브러리 프레임워크 등의 코드도 중요하다. 테스트가 해당 코드들을 범주에 포함시켜 소프트웨어가 의존성에 대해 검증이 올바른지 확인한다.

### 4.1.2 두 번째 요소: 리팩터링 내성

이는 테스트를 **실패하지 않고** 기본 애플리케이션 코드를 **리팩터링**할 수 있는지에 대한 척도다.

기반 코드를 수정하면 기능은 완벽하게 작동하지만, 테스트가 실패하는 경우 이를 **거짓 양성**이라고 한다. 이는 **허위 경보**다. 실제로 기능이 의도한대로 작동하지만 테스트는 실패를 나타낸다. 일반적으로 리팩터링할 때, **구현**을 **수정**하지만 **식별할 수 있는 동작**은 **유지**할 때 발생한다.

리팩터링 내성 지표의 평가 점수는 거짓 양성의 **빈도 수**다. 적을수록 좋으며, 거짓 양성은 전체 테스트 스위트에 영향을 줄 수 있다. 단위 테스트의 목표는 **프로젝트 성장**을 지속 가능하게 하는 것이며, 이 메커니즘은 회귀 없는 **주기적인** 리팩터링으로 새로운 기능을 추가할 수 있는 것이다.

#### 지속 가능한 성장을 하게하는 메커니즘

* 기존 기능이 고장났을 때 테스트가 **조기 경고**를 제공한다. 이는 코드가 운영 환경에 배포되기 전에 문제를 해결할 수 있다.
* 코드 변경이 회귀로 이어지지 않을 것이라고 **확신**하게 된다. 확신이 없다면 리팩터링을 주저하고, 코드 베이스가 나빠질 가능성이 높아진다.

#### 메커니즘을 방해하는 거짓 양성

* 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대한 **대응 능력**과 **의지**가 희석된다. 실패에 익숙해지고 기능이 고장 나도 운영 환경에 배포된다.
* 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 떨어지며, 더 이상 믿을 만한 **안전망**으로 인식하지 않는다. 신뢰가 부족해지면 회귀를 피하려고 코드 변경을 최소한으로 하기 때문에 리팩터링이 줄어든다.

버그가 운영 환경에 배포되는 상황을 대응하기 위한 올바른 방법은 리팩터링의 중단이 아닌 테스트 스위트의 안정성을 높이기 시작하는 것이다.

### 4.1.3 무엇이 거짓 양성의 원인인가?

테스트에서 발생하는 거짓 양성의 수는 테스트와 SUT의 **구현 세부 사항**이 많이 결합 할수록 허위 경보가 더 많이 생긴다. 거짓 양성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 **분리**하는 것 뿐이다.

테스트는 **최종 사용자**의 관점에서 SUT를 검증해야 하고 관련된 **절차**가 아닌 **식별할 수 있는 동작**, 즉 의미 있는 **결과**만 확인해야 하며, 다른 모든 것은 **무시**해야 한다.

구현 세부 사항에 의존하는 테스트는 똑같이 적용할 수 있는 다른 구현을 고려하지 않고 특정 구현만 **예상**에서 테스트한다. 이러한 테스트는 리팩터링 내성이 없다.

### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기

리팩터링 내성을 높이는 방법은 코드의 내부 작업과 테스트를 멀리 떨어뜨리고 **최종 결과**를 목표로 하는 것이다. 이는 테스트를 블랙박스로 취급하고 **식별할 수 있는 동작**에만 신경쓰게 하여 결과적으로 리팩터링 내성을 늘어나게 한다.

구현 세부 사항이 아닌 **결과**에 의존하는 테스트는 항상 적시에 실패하고, 고객에게 영향을 줄 수 있는 애플리케이션의 변경을 알려주기 때문에 개발자가 주의를 기울여야 한다.

하지만 거짓 양성이 완전히 없는 것은 아니다. 메서드의 매개변수가 변경될 경우 발생하는 **컴파일 오류**도 거짓 양성으로 간주한다. 그러나 이러한 거짓 양성은 해결하기 쉬우며, 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다.

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

두 가지 특성은 반대의 관점에서도 테스트 스위트의 정확도에 기여하며, 시간이 흐르면서 프로젝트에 다른 영향을 미친다. 프로젝트가 시작된 직후에는 회귀 방지를 훌륭히 갖추는 것이 중요한 반면, 리팩터링 내성은 바로 필요하지 않다.

### 4.2.1 테스트 정확도 극대화

기능은 고장났지만 테스트가 통과하는 경우 **거짓 음성**이라하며, 기능은 정상이지만 테스트가 실패하는 경우를 **거짓 양성**이라 한다. 이들의 빈도 수는 테스트의 수준을 나타내며, 낮을수록 테스트가 더 정확하다. 이 정확도는 회귀 방지와 리팩터링 내성에 대한 것이며, 이는 테스트 스위트의 **정확도**를 극대화하는 것을 목표로 한다. 정확도 지표는 다음 두 가지로 구성된다.

* 테스트가 버그 있음을 얼마나 잘 나타내는가 (거짓 음성 (회귀 방지 영역) 제외)
* 테스트가 버그 없을을 얼마나 잘 나타내는가 (거짓 양성(리팩터링 내성 영역) 제외)

거짓 양성과 거짓 음성에 대한 테스트 정확도는 **소음 대비 신호 비율** 측면에서 볼 수 있다. 테스트 정확도를 향상시키는 방법은 **신호**를 **증가**시켜 회귀를 더 잘 찾아내는 테스트로 개선하거나, **소음**을 **줄여** 허위 경보를 발생시키지 않는 테스트로 개선하는 것이다.

$테스트 정확도 = \frac {신호(발견된 버그 수)} {소음(허위경보 발생 수)}$

허위 경보가 울리지 않더라도 버그를 찾을 수 없는 테스트와 코드에서 모든 버그를 찾을 수 있더라도 경보가 울리지 않는 테스트의 정확도는 0에 가깝다.

### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계

프로젝트가 시작될 때, 잘못된 경고를 받는 것(거짓 양성)은 버그가 운영 환경에 배포되는 것에 비해 영향력이 작지만, 프로젝트가 성장할수록 거짓 양성은 점점 더 큰 영향을 미치기 시작한다.

리팩터링은 프로젝트 초기에 바로 중요하지 않으며, 시간에 따라 점차 중요해진다. 테스트에서 잘못된 경보가 발생하더라도 쉽게 리팩터링할 수 있다. 하지만 코드베이스는 점점 커지기 때문에 **정기적인** 리팩터링이 없다면 결국 새로운 기능에 드는 비용이 커진다.

리팩터링의 필요성에 따라 리팩터링 내성도 점점 더 중요해지며, (특히 프로젝트 후반에) 거짓 양성이 중요해도 대부분은 회귀 방지에만 중점을 두는 경향이 있는데, 이는 정확한 테스트 스위트를 구축하기에 **충분**하지 않다.

그 이유는 후반까지 가는 프로젝트가 훨씬 적고, 너무 커지기 전에 개발이 끝나기 때문에 모든 리팩터링 작업을 방해하는 잘못된 경보보다 **눈에 띄지 않는** 버그 문제에 직면하게되고 사람들은 버그에 따라 최적화한다. 중대형 프로젝트에서는 거짓 음성(알려지지 않은 버그)과 거짓 양성(허위 경보)에 대해 **똑같이** 주의를 기울여야 한다.

## 4.3  세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

좋은 단위 테스트의 특성 중 남은 두 가지 요소를 살펴보자.

* 빠른 피드백
* 유지 보수성

빠른 피드백은 단위 테스트의 필수 속성이며, 빠를수록 더 많이, 자주 실행할 수 있다. 테스트가 빠르면 **피드백 루프**를 대폭 줄여서, 버그 수정의 비용을 거의 0까지 줄일 수 있다. 느린 테스트는 피드백을 느리게하고 잠재적으로 버그를 뒤늦게 눈에 띄게 해 버그 수정의 비용을 증가시킨다.

마지막으로 유지비를 평가하는 유지 보수성 지표는 두 가지 요소로 구성된다.

* 테스트가 얼마나 이해하기 어려운가
  * 테스트의 **크기**와 관련 있으며, 라인 수를 줄이려고 인위적으로 압축하지 않는다고 가정할 때 테스트는 코드 라인이 **적을수록** 더 쉽다. 테스트 코드의 품질은 제품 코드만큼 중요하며, 테스트의 절차를 생략하지 말고 테스트 코드를 '**일급 시민**'으로 취급하라.
* 테스트가 얼마나 실행하기 어려운가
  * 테스트가 프로세스 외부 종속성으로 작동하면, 의존성의 상시 운영에 시간을 들여야 한다.

## 4.4 이상적인 테스트를 찾아서

좋은 단위 테스트들의 특성을 곱하면 테스트의 가치가 결정된다. 즉, 어떤 특성이라도 0이 되며 **전체가 0이다**.

특성을 정확하게 측정하는 것은 불가능 하지만, 네 가지 특성과 관련해서 비교적 정확하게 평가할 수 있다. 이 평가는 테스트의 **가치 추정치**를 제시하며, 테스트 스위트에 계속 둘지 여부를 결정할 수 있다.

테스트 코드를 포함한 모든 코드는 **책임**이다. 최소 필수 값에 대해 높은 임계치를 설정하고 충족하는 것만 테스트 스위트에 남겨라. 소수의 가치 있는 테스트가 프로젝트를 성장시키는 데 훨씬 효과적이다.

### 4.4.1 이상적인 테스트를 만들 수 있는가?

이상적인 테스트는 각 속성마다 **최대 값**을 받아야 하며, 그런 이상적인 테스트를 만드는 것은 **불가능**하다. 처음 세 가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 **상호 배타적**이기 때문이다. 세 가지 특성 모두 최대로 하는 것은 불가능하며, **하나를 희생해야 둘을 최대로 할 수 있다**. 그리고 곱셉 원리 때문에 하나의 특성을 그냥 버릴 수는 없으며, 어느 것도 크게 줄이지 않는 방식으로 최대한 크게 해야 한다. 한 가지 특성을 희생해 가치가 0에 가까워지는 테스트를 살펴보자.

### 4.4.2 극단적인 사례 1: 엔드 투 엔드 테스트

엔드 투 엔드 테스트는 모든 시스템 구성 요소를 거쳐 **최종 사용자**의 관점에서 시스템을 살펴본다. 이는 프로젝트에서 사용하는 코드를 가장 많이 수행하기 때문에 휘귀 방지를 훌륭히 해낸다. 또한 리팩터링은 식별할 수 있는 동작을 변경하지 않으므로 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다. 이러한 테스트는 어떤 특정 구현도 강요하지 않고, 최종 사용자의 관점에서 기능이 어떻게 동작하는지만 볼 수 있으며, 구현 세부 사항을 최대한 제거한다.

그러나 엔드 투 엔드 테스트에는 **느린 속도**라는 단점이 있다. 의존하는 모든 시스템은 빠른 피드백을 받기 어렵다. 이는 엔드 투 엔드 테스트만으로 코드베이스를 다루기가 불가능한 이유이다. 회귀 오류와 거짓 양성에 대한 방지를 훌륭히 해내지만 속도가 떨어진다. (빠른 피드백의 지표 실패)

### 4.4.3 극단적인 사례 3: 간단한 테스트

엔드 투 엔드 테스트와 달리, 매우 빠르게 실행되고 빠른 피드백을 제공한다. 또한 거짓 양성이 생길 가능성이 낮기 때문에 리팩터링 내성도 우수하다.

그러나 기반 코드에 실수할 여지가 많지 않기 때문에 회귀를 나타내지 않는다. 심지어 이름만 바꿀 뿐 '**동어 반복 테스트**'를 불러온다. 이러한 테스트는 항상 통과하거나 검증이 무의미 하기 때문에 가치가 없다. 우수한 리팩터링 내성과 빠른 피드백을 제공하지만 회귀 방지가 없다.

### 4.4.4 극단적인 사례 3: 깨지기 쉬운 테스트

실행이 빠르고 회귀를 잡을 가능성이 높지만 **거짓 양성**이 많은 테스트를 '**깨지기 쉬운 테이스트**'라고 한다. 이는 리팩터링을 견디지 못하고 해당 기능의 고장 여부와 관계 없이 깨진다. 만약 데이터베이스에서 사용자를 가져올 때 올바른 SQL문을 생성하는지 검증한다면 개발자가 SQL을 엉망으로 할 수도 있고 `UserID` 대신 `ID`로 잘못사용할 수 있기 때문에 테스트가 실패해서 이를 지적한다. 그러나 이런 테스트는 **리팩터링 내성**이 좋지 않다. 다음과 같이 여러 형태로 변형해도 결과는 모두 같다.

```sql
SELECT * FROM dbo.[User] WHERE UserID = 5
SELECT * FROM dbo.User WHERE UserID = 5
SELECT UserId, Name, Email FROM dbo.[USER] WHERE UserID = 5
SELECT * FROM dbo.[User] WHERE UserID = @UserID
```

기능이 계속 동작하더라도 테스트는 깨진다. 이 테스트는 '**어떻게**'에 중점을 두고 있기 때문에 더 이상의 리팩터링은 막으면서 SUT **구현 세부 사항**에 스며들고 있다. 빠르게 실행되고 회귀 방지를 훌륭히 해내지만 리팩터링 내성은 거의 없다.

### 4.4.5 이상적인 테스트를 찾아서: 결론

좋은 단위 테스트의 특성들은 **상호 배타적**이다. 두 가지를 극대화하는 테스트는 만들기 쉽지만, 남은 한 가지를 희생해야만 가능하다. 이상적인 테스트를 만드는 것은 불가능하다.

네 번째 특성인 유지 보수성은 엔드 투 엔드 테스트를 제외하고 처음 세 가지 특성과 상관 관계가 없으며, 엔드 투 엔드 테스트는 모든 의존성의 설정과 관리가 필요하기 때문에 유지비 측면에서 더 비싸다.

좋은 테스트를 만드는 특성 간에 균형을 이루는 것은 어떤 특성도 **0이 되지 않는 식**으로 **절충**해야 하며, 부분적으로 그리고 전략적으로 **희생**해야 한다.

세 가지 특성을 서로 조금씩 인정하는 것이 최선의 전략이라고 생각할 수 있지만, 실제로는 **리팩터링 내성**을 포기할 수 없다. 엔드 투 엔드 테스트만 쓰거나 테스트가 빠르지 않은 한, 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다. 따라서 **회귀 방지**와 **빠른 피드백** 사이의 선택으로 절충이 귀결된다.

리팩터링 내성을 포기할 수 없는 이유는 테스트에 리팩터링 내성이 있거나 없거나 그 사이에 **중간 단계**는 거의 없기 때문이다. 리팩터링 내성은 조금만 인정할 수 없고 완전히 포기해야 할 것이다. 탄탄한 테스트 스위트를 만드는 것은 테스트의 불안정성(**거짓 양성**)을 제거하는 것이 최우선 과제이다.

## 4.5 대중적인 테스트 자동화 개념 살펴보기

기존에 알려진 모든 테스트 자동화 개념은 좋은 단위 테스트의 네 가지 특성으로 거슬러 올라간다. 테스트 피라미드와 **화이트박스** 대 **블랙박스** 테스트라는 두 가지 개념을 살펴본다.

### 4.5.1 테스트 피라미드 분해

테스트 피라미드는 테스트 스위트에서 테스트 유형간의 일정한 비율을 일컫는다.

* 단위 테스트
* 통합 테스트
* 엔드 투 엔드 테스트

피라미드의 각 층의 너비는 테스트의 수이며, 층의 높이는 테스트가 **최종 사용자의 동작**을 얼마나 유사하게 흉내 내는지 나타내는 척도다. 피라미드 상단의 테스트(엔드 투 엔드)는 **회귀 방지**에 유리한 반면, 하단(단위 테스트)는 **실행 속도**를 강조하며, 중단(통합 테스트)은 그 **중간**에 있다.

어느 계층도 **리팩터링 내성**을 포기하지 않는다. 엔드 투 엔드와 통합 테스트는 단위 테스트보다 리팩터링 내성이 더 높지만, 제품 코드에서 분리했을 때의 부작용만큼이며, 단위 테스트조차 리팩터링 내성을 **양보해서는 안된다**. 모든 테스트는 **거짓 양성**을 **가능한 한 적게**하는 것을 목표로 해야 한다.

테스트 유형 간의 비율은 일반적으로 피라미드 형태를 유지해야 한다. 엔드 투 엔드 테스트가 적어야 하는 이유는 빠른 피드백 지표에서 매우 낮은 점수를 받으며, 유지 보수성에도 결여되어 있다. 엔드 투 엔드 테스트는 가장 중요한 기능에 적용할 때와 단위 테스트와 통합 테스트와 동일한 수준으로 보호할 때만 적용된다. 다른 용도로 쓰는 것은 최소 필수 값의 임계치를 넘으면 안된다.

피라미드에는 예외가 있다. 모든 애플리케이션이 비즈니스 규칙이나 기타 복잡도가 거의 없는 CRUD 작업이라면 피라미드는 **직사각형**처럼 보일 것이다. 단위 테스트는 비즈니스 복잡도가 없는 환경에서는 유용하지 않으므로 간단한 테스트 수준까지 빠르게 내려가며, 반면 통합 테스트는 코드가 아무리 단순해도 시스템간의 통합을 확인하는 것은 중요하기 때문에 그 가치가 잘 지켜진다.

또 다른 에외는 프로젝트 외부 의존성 하나만 연결하는 API는 엔드 투 엔드 테스트를 더 많이 두는 것이 적합하다. 사용자 인터페이스가 없기 때문에 상당히 **빠르게 실행**되며, **단일** 외부 의존성이기 때문에 **유지비**도 적다. 기본적으로 이러한 환경에서는 엔드 투 엔드 테스트는 통합 테스트와 구별할 수 없으며, 유일한 차이점은 **진입점**이다.

### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

* 블랙박스 테스트
  * 시스템의 내부 구조를 몰라도 **기능**을 검사할 수 있는 방법이다. 일반적으로 **명세**와 **요구사항**과 같이 무엇을 해야 하는지를 중심으로 구축된다.
* 화이트박스 테스트
  * 블랙박스와 정반대다. **내부 작업을** 검증하며 요구 사항이나 명세가 아닌 **소스 코드**에서 파생된다.

화이트박스 테스트가 더 철저한 편이며, 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다. 하지만 테스트 대상 코드의 특정 구현과 **결합**돼 있기 때문에 깨지기 쉽다. 이는 **거짓 양성**을 많이 내고 **리팩터링 내성**이 부족하다. 또한 의미 있는 동작으로 유추할 수 없는데, 이는 화이트박스 테스트가 **취약**하고 **가치**를 많이 부여하지 않는다는 강력한 신호다.

화이트박스는 **회귀 방지**에는 좋지만 **리팩터링 내성**이 부족하며, 리팩터링 내성은 타협할 수 없기 때문에 블랙박스 테스트를 **기본**으로 선택하여 문제 영역에 **의미 있는 동작**을 확인해야 한다. 테스트를 통해 비즈니스 요구 사항으로 도달하지 못한다면, 이는 깨지기 쉽기 때문에 테스트를 **재구성**하거나 **삭제**해야 한다. 유일한 예외는 알고리즘 복잡도가 높은 유틸리티 코드이다.

테스트를 **분석**할 때는 화이트박스를 사용할 수 있다. 코드 커버리지를 통해 실행하지 않은 분기를 확인한 다음 코드 내부 구조에 대해 **전혀 모르는 것처럼** 테스트하는 것이다.
