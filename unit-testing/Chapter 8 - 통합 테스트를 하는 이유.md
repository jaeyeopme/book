# Chapter 8 - 통합 테스트를 하는 이유

단위 테스트에만 전적으로 의존하면 시스템의 **전체적인 동작**에 대해 확신할 수 없다. 단위 테스트의 비즈니스 로직을 **외부**와 **단절**된 상태로 확인하는 것만으로 충분하지 않다. 이 장에서는 통합 테스트에 대해 알아본다.

## 8.1 통합 테스트는 무엇인가?

통합 테스트는 테스트 스위트에서 중요한 역할을 하며, 단위 테스트와 **균형**을 맞추는 것도 중요하다. 단위 테스트와 통합테스트의 차이점을 알아본다.

### 8.1.1 통합 테스트의 역할

단위 테스트는 다음 세 가지 요구 사항을 충족한다.

* 단일 동작 단위를 검증한다.
* 빠르게 수행한다.
* 다른 테스트와 별도로 처리한다.

이 세 가지 요구사항 중 **하나라도 충족하지 못하는 테스트**가 통합 테스트 범주에 속한다.

통합 테스트는 대부분 **시스템**이 **프로세스 외부 의존성**과 통합해 어떻게 작동하는지 검증한다. 다시 말해, 컨트롤러 사분면에 속하는 코드를 다룬다. 단위 테스트는 도메인 모델을 다루는 반면, 통합 테스트는 **프로세스 외부 의존성**과 **도메인 모델**을 **연결**하는 코드를 확인한다.

모든 **프로세스 외부 의존성**을 **목**으로 대체하면 **공유 의존성**이 없어지기 때문에 테스트 **속도**가 빨라지고 **격리**되지만, 대부분의 애플리케이션은 **목**으로 **대체할 수 없는 프로세스 외부 의존성**이 있다. 대게 데이터베이스 같은 경우 다른 애플리케이션에서 **볼 수 없는 의존성**이다.

간단한 코드는 노력을 들일 가치가 없고, 지나치게 복잡한 코드는 알고리즘과 컨트롤러로 리팩터링 해야 한다. 따라서 모든 테스트는 **도메인 모델**과 **컨트롤러** 사분면에만 초점을 맞춰야 한다.

### 8.1.2 다시 보는 테스트 피라미드

통합 테스트가 **프로세스 외부 의존성**에 **직접 작동**하면 느려지며, 유지비가 증가한다. 유지비가 증가하는 이유는 다음과 같다.

* 프로세스 외부 의존성 **운영**이 필요함
* 관련된 **협력자**가 많아서 테스트가 비대해짐

하지만 통합 테스트는 코드(라이브러리 코드 포함)를 더 많이 거치기 때문에 **회귀 방지**가 단위 테스트보다 좋다. 또한 제품 코드와 **결합도**가 낮아서 **리팩터링 내성**도 좋다.

단위 테스트와 통합 테스트의 비율은 프로젝트 특성에 따라 다르지만, 일반적으로 단위 테스트로 **가능한 한 많이** 비즈니스 시나리오의 _예외 상황_을 확인하고, 통합 테스트는 _주요 흐름_과 단위 테스트가 **다루지 못한** 예외 상황을 다룬다.

> 주요 흐름은 시나리오의 성공적인 실행을 말하며, 예외 상황은 비즈니스 시나리오 수행 중 오류 발생을 말한다.

<p align="center">
<img src="https://shorturl.at/iBKLY" alt="테스트 피라미드" width="500" height="400" />
</p>

대부분 단위 테스트로 전환하면 **유지비**를 절감할 수 있으며, **비즈니스 시나리오 당** 중요한 통합 테스트가 하나 또는 두 개 있으면 시스템 **정확도**를 보장할 수 있다.

통합 테스트는 단순한 애플리케이션에도 가치가 있다. 코드가 간단한지 보다 다른 **서브 시스템**과 **통합**해 어떻게 작동하는지 확인하는게 더 중요하다.

### 8.1.3 통합 테스트와 빠른 실패

통합 테스트에서 **프로세스 외부 의존성**과의 상호 작용을 모두 확인하려면 **가장 긴 주요 흐름**을 선택하라. 모든 상호 작용이 거치는 흐름이 없다면, **외부 시스템**과의 **통신**을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가하라. 하지만 어떤 예외 상황에 잘못 실행 돼 전체 애플리케이션이 즉시 실패한다면 해당 상황은 테스트할 필요가 없다.

예를 들어 7장에서의 CRM 시스템의 User의 `ChangeEmail()`를 보자.

```cs
// CRM 의 사용자의 ChangeEmail 메서드

public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail != null);
    ...
}
```

컨트롤러는 `CanChangeEmail()`를 호출하고 해당 메서드가 오류를 반환하면 연산을 **중단**한다.

```cs
// CRM 의 사용자 컨트롤러의 ChangeEmail 메서드

public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);
    
    // 예외 상황
    string error = user.CanChangeEmail();
    if (error != null)
        return error;
    ...
}
```

이 예제는 이론적으로 통합 테스트를 다룰 수 있는 상황을 보여주지만, 이러한 테스트는 **가치가 없다**. 컨트롤러가 먼저 `CanChangeEmail()`을 참조하지 않고 이메일을 변경한다면 애플리케이션이 **충돌**하며, 이는 처음 실행으로 버그가 드러나고 **쉽게 알아차리고** 고칠 수 있다. 또한 **데이터 손상**으로 이어지지 않는다.

컨트롤러에서 `CanChangeEmail()`이 아닌 User에 **사전 조건**이 있는지를 테스트해야 한다. 이는 통합 테스트가 필요 없다.

버그를 빨리 나타나게 하는 것을 _빠른 실패 원칙_이라고 하며, 통합 테스트에서 할 수 있는 대안이다.

> 빠른 실패 원칙은 예기치 않은 오류가 **발생하자마자** 현재 연산을 중단하는 것이다. 보통 예외를 **던져** 현재 연산을 중지한다. 예외는 프로그램을 중단하고 실행 스택에서 가장 높은 레벨로 올라간 후 로그를 남기고 작업을 종료하거나 재시작할 수 있다.

## 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

통합 테스트에서 시스템과 **프로세스 외부 의존성**의 통합을 검사하는 두 가지 방법이 있다. **실제** 프로세스 외부 의존성을 사용하거나 해당 의존성을 **목**을 대체하는 것이다.

### 8.2.1 프로세스 외부 의존성의 두 가지 유형

* 관리 의존성(전체를 **제어**할 수 있는 의존성)
  * 애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과의 **상호 작용**은 **외부에서 볼 수 없다**. 대표적인 예로 데이터베이스가 있다.
* 비관리 의존성(전체를 **제어**할 수 없는 의존성)
  * 해당 의존성과의 **상호 작용**을 **외부에서 볼 수 있기** 때문에 다른 애플리케이션에서 볼 수 있는 **부작용**을 발생시킨다. 대표적인 예로 SMTP 서버와 메시지 버스 등이 있다.

**관리 의존성**과의 통신은 **세부 구현 사항**이기 때문에 **실제 인스턴스**를 사용하고, **비관리 의존성**과의 통신은 시스템의 **식별할 수 있는 동작**이기 때문에 **목**으로 대체해야 한다.

5장에서 살펴봤듯이, 비관리 의존성에 대한 **통신 패턴**을 유지해야 하는 것은 **하위 호환성**을 지키기 위함이며, 이는 **목**을 사용해 모든 가능한 리팩터링을 고려해 **통신 패턴 영속성**을 보장할 수 있다.

관리 의존성은 다르다. 외부 클라이언트는 데이터베이스를 어떻게 구성하는지 신경쓰지 않는다. 중요한 것은 **최종 상태**이며, 통합 테스트에서 **실제 인스턴스**를 사용해 최종 상태를 **확인**할 수 있다.

### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

때로는 모두의 속성을 나타내는 프로세스 외부 의존성이 있으며, 대표적인 예로 다른 애플리케이션이 접근할 수 있는 **공유 데이터베이스**가 있다. 시스템은 전용 데이터베이스로 시작하지만, 이내 다른 시스템이 같은 데이터베이스의 데이터를 요구하기 시작해, 다른 시스템과 쉽게 통합하기 위해 일부 테이블만 접근 권한을 공유하기로 한다.

시스템 간의 통합을 구현하는 데 데이터베이스를 사용하면 시스템이 서로 결합되고 추가 개발을 복잡하게 만든다. API(동기식 통신)나 메시지 버스(비동기식 통신)를 사용하는 것이 더 낫다.

그러나 이미 공유 데이터베이스가 있고 근래에 할 수 있는 것이 아무것도 없다면, 이 경우 다른 애플리케이션이 **볼 수 있는 테이블**을 **비관리 의존성**으로 취급해야 한다. 이러한 테이블은 사실상 메시지 버스 역할을 한다. 이 테이블을 이용한 **통신 패턴**이 바뀌지 않도록 하려면 **목**을 사용하라. 그리고 나머지 데이터베이스를 **관리 의존성**으로 처리하고, **상호 작용**을 검증하지 말고 **최종 상태**를 확인하라. **꼭 필요한 경우가 아니라면 시스템이 해당 테이블과 상호 작용하는 방식을 변경하지 말라!**

### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?

때로는 관리 범위를 벗어나기 때문에 통합 테스트에서 **관리 의존성**을 실제 버전으로 사용할 수 없는 경우가 있는데 대표적으로 **테스트 자동화 환경**에 **배포할 수 없는** 레거시 데이터베이스인 경우가 있다.

하지만 **관리 의존성**도 **목**으로 처리한다면 통합 테스트의 **리팩터링 내성**과 **회귀 방지**는 **저하**된다. 이러한 통합 테스트(단위 테스트도)가 하는 일은 컨트롤러가 어떤 리포지터리 메서드를 호출하는지 검증할 뿐이며, 컨트롤러에 있는 코드 세줄을 제외한 **어떠한 것도 신뢰할 수 없다**.

데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 **아예** 작성하지 말고 **도메인 모델**의 **단위 테스트**만 집중하라. 가치가 충분하지 않은 테스트는 테스트 스위트에 있어서는 안된다.

## 8.3 통합 테스트: 예제

CRM 시스템을 어떻게 통합 테스트 하는지 알아보자. 이 시스템은 사용자 이메일 변경 기능만 구현돼 있다. 데이터베이스의 사용자와 회사를 검색하고 **의사 결정**을 **도메인 모델**에 **위임**한 다음, 결과를 데이터베이스에 다시 저장하고 필요한 경우 메시지 버스에 메시지를 싣는다.

```cs
// 사용자 컨트롤러

public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();
    
    public void ChangeEmail(int userId, string newEmail)
    {
        
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);
        
        string error = user.CanChangeEmail();
        if (error != null)
            return error;
        
        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);
        
        user.ChangeEmail(newEmail, company);
            
        _database.SaveCompany(newNumberOfEmployees);
        _database.SaveUser(user);
        
        foreach(EmailChangedEvent ev in user.EmailChangedEvents)
        {
            _messageBus.SendEmailChangeMessage(ev.userId, ev.NewEmail);    
        }
        return "OK";
    }
}
```

다음 절에서는 통합 테스트를 통해 검증할 시나리오를 개략적으로 설명한다.

### 8.3.1 어떤 시나리오를 테스트할까?

통합 테스트에 대한 일반적인 지침은 **가장 긴 주요 흐름**과 단위 테스트로 수행할 수 없는 모든 **예외 상황**을 다루는 것이다. 가장 긴 주요 흐름이란 모든 **프로세스 외부 의존성**을 거치는 것이다.

CRM 시스템의 가장 긴 주요 흐름은 기업 이메일에서 일반 이메일로 변경하는 것이며, 이 변경은 부작용이 가장 많다.

* 데이터베이스에서 사용자와 회사 모두 업데이트된다.
  * 사용자는 유형과 이메일을 변경한다.
  * 회사는 직원수를 변경한다.
* 메시지 버스로 메시지를 보낸다.

이메일을 변경할 수 없는 시나리오는 단위 테스트로 테스트하지 않는 **예외 상황**이다. 그러나 컨트롤러에 이러한 확인이 없으면 애플리케이션이 **빨리 실패**하기 때문에 테스트할 필요가 없다. 다음과 같은 통합 테스트 하나만 남는다.

```cs
public void Changing_email_from_corporate_to_non_corporate()
```

### 8.3.2 데이터베이스와 메시지 버스 분류하기

통합 테스트를 작성하기 전 **프로세스 외부 의존성**을 두 가지로 분류해서 **직접** 테스트할 대상과 **목**으로 대체할 대상을 **결정**해야 한다. 데이터베이스는 애플리케이션 이외는 접근할 수 없기 때문에 **관리 의존성**이며, **실제 인스턴스**를 사용해야 한다.

#### 통합 테스트 절차

* 데이터베이스에 사용자와 회사를 추가한다.
* 데이터베이스에서 이메일 변경 시나리오를 실행한다.
* 데이터베이스 **상태**를 검증한다.

반면 메시지 버스는 **비관리 의존성**이다. 메시지 버스의 목적은 다른 시스템과의 **통신**을 가능하게 하는 것 뿐이기 때문에 통합 테스트는 이를 **목**으로 대체하고 **컨트롤러와** **목** 간의 **상호 작용**을 **검증**하게 된다.

### 8.3.3 엔드 투 엔드 테스트는 어떤가?

샘플 프로젝트에서 E2E 테스트는 없을 것이다. 이는 어떤 프로세스 외부 의존성도 목으로 대체 하지 않을 것을 의미하며, 사용 여부는 각자의 판단에 맡긴다. 대부분의 경우 통합 테스트에 **관리 의존성**을 **포함** 시키고 **비관리 의존성**은 **목**으로 대체하면 **통합 테스트**의 **보호 수준**은 **E2E 테스트**와 **비슷**해진다. 하지만 배포 후 상태 점검을 위해 한 두개 정도는 작성할 수 있다. 외부 클라이언트의 동작을 **모방**하려면 메시지 버스는 **직접** 확인하고, 데이터베이스의 상태는 **간접적**으로(직접 확인해서는 안됨) 애플리케이션을 통해 검증한다.

### 8.3.4 통합 테스트: 첫 번째 시도

```cs
// 통합 테스트

[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    // Arrange
    var db = new Database(ConnectionString);
    
    // 재사용을 위한 헬퍼 메서드 CreateUser, CreateCompany
    User user = CreateUser(
        "user@mycorp.com" UserType.Employee, db);
    CreateCompany("mycorp.com", 1, db);
    
    var messageBusMock = new Mock<IMessageBus>();
    var sut = new UserController(db, messageBusMock.Object);
    
    // Action
    string result = sut.ChangeEmail(user.UserId, "new@gmail.com")
    
    // Assert
    Assert.Euqal("OK", result);
    
    object[] userData = db.GetUserById(user.UserId);
    User userFromDb = UserFactory.Createa(userData);
    Assert.Equal("new@gmail.com", userFromDb.Email);
    Assert.Equal(UserType.Customer, userFromDb.Type)
      
    object[] companyData = db.GetCompany();
    Company companyFromDb = CompanyFactory
        .Create(companyData);
    Assert.Equal(0, companyFromDb.NumberOfEmployees);
    
    messageBusMock.Verify(
        x => x.SendEmailChangedMessage(
            user.UserId, "new@gmail.com"),
        Times.Once)
}
```

입력 매개변수 데이터와 별개로 데이터베이스의 **상태**를 확인하는 것이 중요하기 때문에 검증 구절에서 사용자와 회사 데이터를 각각 조회하고 해당 **상태**를 검증만 한다. 이는 테스트가 데이터베이스에 대해 읽기와 쓰기를 모두 수행하기 때문에 **회귀 방지**를 최대로 얻을 수 있다. 읽기는 **컨트롤러**에서 내부적으로 사용하는 **동일한 코드**를 써서 구현해야 한다. 추가적인 개선으로 **헬퍼 메서드**를 사용해 검증 구절도 크기를 줄일 수 있다.

## 8.4 의존성 추상화를 위한 인터페이스 사용

단위 테스트 영역에서 가장 많이 오해하는 주제이다. 인터페이스를 둔 이유를 개발자들이 자주 잘못 설명하고, 그 결과 **남용**하는 경향이 있다. 이 절에서는 어떤 환경에서 바람직하거나 바람직하지 않은지를 알아본다.

### 8.4.1 인터페이스와 느슨한 결합

많은 개발자가 **프로세스 외부 의존성**을 위해 인터페이스를 도입한다. 심지어 인터페이스 **구현**이 **하나** 있는 경우에도 그렇다. 이 관습은 아무도 의문을 제기하지 않는다. 인터페이스를 사용하는 일반적인 이유는 다음과 같다.

* 프로세스 외부 의존성을 **추상화**해 **느슨한 결합**을 달성한다.
* 기존 코드를 **변경**하지 않고 새로운 기능을 **추가** 해 **OCP**를 지킨다.

이 두 가지 이유 모두 **오해**이다. **단일 구현**을 위한 인터페이스는 **추상화**가 **아니며**, 해당 인터페이스를 구현하는 **구체 클래스**보다 **결합도**가 **낮지 않다**.

진정한 추상화는 **발견**하는 것이지 **발명**하는 것이 아니며, 의미상 추상화가 이미 존재하지만 코드에서 아직 명확하게 정의되지 않았을 때 **그 이후**에 **발견**되는 것이다. 인터페이스가 진정으로 추상화되려면 **구현**이 **적어도 두 가지**는 있어야 한다.

두 번째 이유는 더 기본적인 원칙인 _YAGNI_를 위반한다. 이는 **향후 기능**이 어떤지 설명하려고 기능을 **개발**해서도, 기존 코드를 **수정**해서도 안되며, 크게 두 가지 이유가 있다.

* 기회 비용
  * 현재 비즈니스 담당자들에게 **필요하지 않은 기능**에 보내는 시간은 지금 당장 필요한 기능을 재치고 **시간을 허비**하는 것이다. 게다가 마침내 개발한 기능을 요구하더라도 비즈니스 담당자들의 **눈높이**는 높아져 있을 것이며, **여전히** 코드를 **수정**해야 한다. 처음부터 **실제 필요에 따라** 기능을 구현하는 것이 더 유리하다.
* 프로젝트 코드가 적을 수록 좋다.
  * 요구 사항이 바로 있는 경우가 아닌 **만일**을 위해서라도 작성한 새로운 코드는 코드 베이스의 **소유 비용**을 불필요하게 증가시킨다. 해결책에 **필요한 코드**가 **적고 간단할 수록** 더 좋다.

> YAGNI 란 "You aren't gonna need it" 의 약자이며 현재 **필요하지 않은 기능**에 시간을 들이지 말라는 것이다.

### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

인터페이스에 **구현**이 **하나**라도 **프로세스 외부 의존성**에 **인터페이스**를 사용하는 이유는 **목**을 사용하기 위함이다. **테스트 대역**을 만들 수 없으면 **시스템**과 **프로세스 외부 의존성** 간의 **상호 작용**을 확인할 수 없다.

따라서 목 처리가 필요한 경우(비관리 의존성)가 아니라면 **인터페이스를 두지 말라**. 관리 의존성은 컨트롤러에 **명시적으로 주입**하고, 해당 의존성을 **구체 클래스**로 사용하라.

CRM 시스템에서 UserController의 생성자에는 메시지 버스만 인터페이스로 되어있다. 데이터베이스의 경우 **관리 의존성**이기 때문에 **인터페이스가 필요 없다**.

### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용

프로세스 외부 의존성 뿐 아니라 **프로세스 내부 의존성**도 인터페이스 기반인 코드가 있다. 또한 마찬가지로 **구현**이 **하나**라면 사용하면 **안된다**. 또한 단일 구현으로 인터페이스를 도입하는 이유도 **목**을 **처리**하기 위한 것뿐이다. 그러나 프로세스 내부 의존성은 **도메인** 클래스 간의 **상호 작용**을 확인한다면 **깨지기 쉬운 테스트**로 이어지고, 결국 리팩터링 내성이 떨어지기 때문에 사용해선 안된다.

## 8.5 통합 테스트 모범 사례

통합 테스트를 최대한 활용하기 위한 일반적인 지침이 있다.

* 도메인 모델 **경계** 명시하기
* 애플리케이션 내 **계층** 줄이기
* **순환 의존성** 제거하기

늘 그렇듯이, **코드 베이스의 상태**를 개선하는 편이다.

### 8.5.1 도메인 모델 경계 명시하기

항상 도메인 모델을 코드 베이스에서 **명시적이고 잘 알려진 위치**에 둬라. **도메인 모델**은 프로젝트가 해결하고자 하는 문제에 대한 **도메인 지식의 모음**이다. 이는 테스트에도 도움이 되며, 7장에서 살펴봤듯이 단위 테스트는 **도메인 모델**과 **알고리즘**을 대상으로 하고, 통합 테스트는 **컨트롤러**를 대상으로 한다. 도메인 클래스와 컨트롤러 사이의 **명확한 경계**는 **단위 테스트**와 **통합 테스트**의 **차이점**을 쉽게 구별할 수 있다.

### 8.5.2 계층 수 줄이기

대부분의 프로그래머는 **간접 계층**을 추가해 코드를 **추상화**하고 **일반화**하려 하지만, 극단적인 경우 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고 **숨은 로직**을 이해하기가 너무 어려워진다. 간접 계층은 코드를 **추론**하는 데 **부정적인 영향**을 미친다. **모든 조각을 하나의 그림**으로 만드는 데 상당한 노력이 필요하다.

추상화가 지나치게 많다면 단위 테스트와 통합 테스트에도 도움이 되지 않는다. 간접 계층이 많은 코드베이스는 컨트롤러와 도메인 모델 사이에 **명확한 경계**가 없는 편이다. 그리고 각 계층을 따로 검증하는 경향이 강하기 때문에 통합 테스트는 가치가 떨어지며, 각 테스트는 특정 계층의 코드만 실행하고 하위 계층은 목으로 처리한다.

가능한 한 간접 계층을 **적게** 사용하라. 대부분 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층(보통 도메인 모델에 속하지 않는 알고리즘과 프로세스 외부 의존성에 접근할 수 있는 코드) 이 세 가지만 활용하면 된다.

### 8.5.3 순환 의존성 제거하기

> **순환 의존성**이란 둘 이상의 클래스가 제대로 작동하고자 직간접적으로 **서로** 의존하는 것이다.

순환 의존성의 대표적인 예는 **콜백**이다. 추상 계층이 너무 많은 것과 마찬가지로, 순환 의존성은 코드를 읽고 이해하려고 할 때 해결책을 찾기 위한 **출발점**이 명확하지 않기 때문에 알아야 할 것이 많다.

또한 순환 의존성은 테스트를 방해한다. **동작 단위**를 **분리**하려면 인터페이스에 의존해 **목**으로 처리해야 하는 경우가 많으며, 이는 **도메인 모델** 테스트할 때 해서는 안된다. **인터페이스**를 통해 순환 의존성의 문제를 **가려** 컴파일 타임에 순환 참조를 제거하더라도 여전히 **런타임**에는 **순환**이 있다.

순환 의존성을 처리하는 가장 좋은 방법은 **제거**하는 것이다. 순환 참조를 다시 호출하는 것 대신 **작업 결과 값**을 **반환**하라. 코드베이스에서 순환 의존성을 모두 제거하는 것은 불가능하지만, **의존성 그래프**의 크기를 **가능한 한 작게** 만들어야 손상을 최소화할 수 있다.

### 8.5.4 테스트에서 다중 실행 구절 사용

3장에서 살펴봤듯이, 테스트에서 두 개 이상의 준비나 실행 또는 검증 구절은 하나의 테스트에서 여러 가지의 **동작 단위**를 테스트하기 때문에 '**코드 악취**'에 해당한다. 하나의 단위 테스트가 아닌 **통합 테스트**에서 두 가지  세가지만 활용하면 된다.를 확인하는게 더 낫다.

예를 들어 사용자 등록과 삭제 두 가지 관련 유스케이스가 있다면 다음과 같은 구조를 가질 수 있다.

* 준비
  * 사용자 등록에 필요한 데이터 준비
* 실행
  * UserController.RegisterUser() 호출
* 검증
  * 등록이 성공적으로 완료됐는지 확인하기 위해 데이터베이스 조회
* 실행
  * UserController.DeleteUser() 호출
* 검증
  * 사용자가 삭제됐는지 확인하기 위해 데이터베이스 조회

이러한 방식은 사용자의 상태가 **자연스럽게** 흐르기 때문에 **설득력**있으며, 첫 번째 실행(사용자 등록)이 두 번째 실행(사용자 삭제)의 **준비 단계** 역할을 할 수 있다. 하지만 문제는 이러한 테스트가 초점을 잃고 순식간에 커질 수 있다.

각 실행을 **고유의 테스트**로 **추출**해 나누는 것이 좋다. 이 작업은 장기적으로 유리하며, **단일 동작 단위**에 초점을 맞춘다면 테스트를 더 쉽게 이해하고 수정할 수 있다.

하지만 원하는 상태로 만들기 어려운 **프로세스 외부 의존성**으로 작동하는 테스트인 경우 **예외**이다. 프로세스 외부 의존성이 너무 **느리거나** **호출 수**를 **제한**하는 경우 **여러 동작**을 하나의 테스트로 **묶어서** 상호 작용의 횟수를 줄이는 것이 더 유리하다.

정리하자면 두 개 이상의 동작 단위를 테스트 하는 경우는 외부 의존성을 관리하기 어려운 경우 뿐이다. 통합 테스트 조차도 실행을 여러 단계로 하는 경우는 드물다. 실제로 **다단계 테스트**는 거의 항상 엔드 투 엔드 테스트 범주에 속한다.

## 8.6 로깅 기능을 테스트하는 방법

로깅 테스트에 관해서는 어떻게 해야 할지 분명하지 않다. 그것은 다음과 같은 질문으로 나눌 수 있다.

* 로깅을 조금이라도 테스트해야 하는가?
* 만약 그렇다면 어떻게 테스트해야 하는가?
* 로깅이 얼마나 많으면 충분한가?
* 로거 인스턴스를 어떻게 전달할까?

### 8.6.1 로깅을 테스트해야 하는가?

로깅은 **횡단 기능**으로, 코드베이스 어느 부분에서도 필요할 수 있다. 다음은 CRM 시스템의 User 클래스의 로깅 예제이다.

```cs
// User 클래스의 로깅 예제

public class User
{
    public void ChangeEmail(string newEmail, Company company)
    {
        _logger.Info(
            $"Changing email for user {UserId} to {newEmail}");
        ...
        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
            _logger.Info(
                $"User {UserId} changed type" +
                $"from {Type} to {newType}");
        }
        ...
        _logger.Info(
            $"Email is changed for user {UserId}");
    }
}
```

로깅은 애플리케이션의 동작에 대해 중요한 정보를 생성한다. 하지만 로깅은 너무 보편적이기 때문에 노력을 들일 **가치**가 분명하지 않기 때문에 테스트 해야하는지에 대한 질문은 "로깅이 애플리케이션의 **식별할 수 있는 동작**인가, 아니면 **구현 세부 사항**인가?" 로 답할 수 있다.

그런 면에서 다른 기능들과 다르지 않으며, 결국 로깅은 로그 저장소와 같은 **프로세스 외부 의존성**에 부작용을 초래한다. 고객이나 애플리케이션의 클라이언트 또는 개발자 이외의 다른 사람이 **보는 경우**라면 이는 **식별할 수 있는 동작**이므로 반드시 테스트해야 한다. 하지만 아무도 개발자 뿐이라면 이는 **구현 세부 사항**이기 때문에 테스트를 하면 안 된다. 예를 들어 비즈니스 담당자가 애플리케이션의 **흐름**을 **기록**해야 한다면 이는 **비즈니스 요구 사항**이기 때문에 테스트를 거쳐야 한다.

스티브 프리먼과 냇 프라이스의 'Growing Object-Oriented Software, Guided by Tests'에서는 로깅을 두 가지 유형으로 나눈다.

* 지원 로깅
  * 지원 담당자나 시스템 관리자가 **추적**할 수 있는 메시지를 생성한다.
* 진단 로깅
  * 개발자가 애플리케이션 내부 상황을 **파악**할 수 있도록 돕는다.

### 8.6.2 로깅을 어떻게 테스트해야 하는가?

로깅에는 **프로세스 외부 의존성**이 있기 때문에 외부 의존성에 영향을 주는 다른 기능들과 동일한 규칙이 적용된다. 그러나 Logger 인터페이스를 **목**으로 처리하지 말라. **지원 로깅**의 경우 **비즈니스 요구 사항**이기 때문에 코드베이스에 **명시적**으로 반영하라. 특별한 DomainLogger 클래스를 만들어 ILogger 대신 해당 클래스와의 **상호 작용**을 확인하라. 다음 예제는 DomainLogger 클래스를 도입한 후의 User 클래스다.

```cs
DomainLogger 클래스에 대한 지원 로그 추출

public class User
{
    public void ChangeEmail(string newEmail, Company company)
    {
        // 진단 로그
        _logger.Info(
            $"Changing email for user {UserId} to {newEmail}");
        ...
        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
            // _logger.Info(
            //    $"User {UserId} changed type" +
            //    $"from {Type} to {newType}");
            
            // 지원 로그
            _domainLogger.UserTypeHasChanged(
                UserId, Type, newType);
        }
        ...
        // 진단 로그
        _logger.Info(
            $"Email is changed for user {UserId}");
    }
}
```

진단 로깅은 기존 로거(ILogger)를 사용하지만, 지원 로깅은 이제 IDomainLogger 타입의 새로운 domainLogger **인스턴스**를 사용한다.

```cs
// ILogger 위의 래퍼로 사용되는 DomainLogger

public class DomainLogger : IDomainLogger
{
    private readonly ILogger _logger;
    
    public DomainLogger(ILogger logger)
    {
        _logger = logger;
    }
    
    public void UserTypeHasChanged(
        int userId, UserType oldType, UserType newType)
    {
        _logger.Info(
            $"User {UserId} changed type" +
            $"from {Type} to {newType}");
    }
}
```

DomainLogger는 ILogger 위에서 작동하며, 도메인 언어를 사용해 **특정 로그 항목**을 **선언**하므로, 지원 로깅을 더 쉽게 이해하고 유지 보수할 수 있다. 이는 **구조화된 로깅** 개념과 매우 유사하기 때문에 로그 파일의 후처리와 분석에서 **유연성**이 크게 향상된다.

구조화된 로깅은 **로그 데이터 캡처**와 **랜더링**을 분리하는 로깅 기술이다. 전통적인 로깅은 문자열을 만든 다음 로그 저장소에 해당 문자열을 기록하는 방식으로 작동하지만, 이 방식은 로그 파일을 **분석**하기 **어렵다**. 예를 들어 특정 유형의 메시지가 몇개인지, 특정 사용자 ID와 관련 있는 메시지 추적 등을 알기가 쉽지 않다.

반면 구조화된 로깅은 로그 저장소에 **구조**가 있다. 구조화된 로깅 라이브러리는 전통적인 방식과 표면적으로는 비슷해보인다. 그러나 **기저의 동작**은 다르다. 메시지 템플릿의 해시(**공간 효율성**을 위해 메시지를 **인덱스 저장소**에 저장)를 계산하고 입력 매개변수와 결합해 캡처한 **데이터 세트**를 형성한다. 다음은 캡처한 데이터를 기존 로깅처럼 평범한 로그 파일을 사용할 수 있지만 JSON 또는 CSV 파일로 **랜더링**할 수도 있다.

DomainLogger는 구조화된 로깅은 아니지만 동일한 방식으로 동작한다. UserTypeHasChanged를 메시지 템플릿의 해시로 볼 수 있다. 이 해시에 매개변수를 덧붙여 로그 데이터를 만든다. 그리고 로그 데이터의 랜더링을 쉽게 추가할 수 있다.

앞서 살펴본 DomainLogger에는 **프로세스 외부 의존성**(로그 저장소)이 있다. User가 해당 의존성과 상호 작용하기 때문에 **비즈니스 로직**과 **프로세스 외부 의존성**과의 **분리**해야 하는 원칙을 위반한다.

이 문제는 사용자 이메일 변경에 대해 외부 시스템에 알림을 구현한 것과 같은 방식(**도메인 이벤트** 사용)으로 해결할 수 있다. 별도의 **도메인 이벤트**를 도입해 **컨트롤러**에서 **변경 사항**을 DomainLogger 호출로 변환한다.

```cs
// User의 DomainLogger를 도메인 이벤트로 교체

public void ChangeEmail(string newEmail, Company company)
{
    ...
    AddDomainEvent(
        new UserTypeChangedEvent(
            UserId, Type, newType));
    ...
}
```

UserTypeChangedEvent와 EmailChangedEvent 두 가지 이벤트는 같은 **인터페이스**를 구현하므로 같은 컬렉션에 저장할 수 있다.

```cs
// UserController의 현재 버전

public string ChangeEmail(int userId, string newEmail)
{
    ...
    _eventDispatcher.Dispatch(user.DomainEvents);
    ...
}
```

EventDispatcher는 **도메인 이벤트**를 **프로세스 외부 의존성**에 대한 **호출**로 **변환**하는 새로운 클래스다.

이제 **지원 로깅**을 테스트하는 것은 다른 **비관리 의존성**을 테스트하는 것과 다르지 않다.

* 단위 테스트는 테스트 대상 User에서 UserTypeChangedEvent **인스턴스**를 확인해야 한다.
* 단일 통합 테스트는 목을 써서 DomainLogger와의 **상호 작용**이 올바른지 확인해야 한다.

도메인 클래스가 아닌 컨트롤러에서 **지원 로깅**이 필요한 경우 **도메인 이벤트**를 사용할 필요가 **없다**. 컨트롤러는 해당 로거를 **직접 사용**할 수 있다.

User 클래스에는 아직 **진단 로깅**이 남아있다. 하지만 이를 테스트할 필요는 없고 가능하면 **도메인** 클래스에 **진단 로깅**을 **사용하지 않는 것**이 좋다. 이유는 다음 절에서 설명한다.

### 8.6.3 로깅이 얼마나 많으면 충분한가?

**지원 로깅**은 **비즈니스 요구 사항**이기 때문에, 여기에는 여지가 없다. 그러나 **진단 로깅**은 과도하게 사용하지 않아야 한다. 이유는 다음과 같다.

* 과도한 로깅은 코드를 **혼란**스럽게 한다. 이는 특히 **도메인 모델**에 해당한다. 진단 로깅을 사용하면 코드가 모호해진다.
* 핵심은 로그의 **신호 대비 잡음 비율**이다. 로그가 많을수록 관련 정보는 찾기 어려워지며, **신호**를 최대한 **늘리고** **잡음**을 **줄여라**.

**도메인 모델**에서 **진단 로깅**을 **절대**사용하지 않도록 하라. 대부분 **컨트롤러**로 옮길 수 있다. 디버깅을 위한 **일시적인** 진단 로깅만 사용하고 디버깅이 끝나면 제거하라. 이상적으로는 처리되지 않는 **예외**만 로깅을 사용해야 한다.

### 8.6.4 로거 인스턴스를 어떻게 전달하는가?

한 가지 방법은 다음 **정적 메서드**를 사용하는 것이다.

```cs
// 정적 필드에 ILogger 저장

public class User
{
    private static readonly ILogger _logger =
        LogManager.GetLogger(typrOf(User));
}
```

스티븐 반 듀르센과 마크 시먼의 'Dependency Injection'에서 이러한 의존성 획득을 **앰비언트 컨텍스트**라고 부른다. 이는 **안티 패턴**이며, 다음 두 가지 단점이 있다.

* 의존성이 숨어있고 변경하기 어렵다.
* 테스트가 더 어려워진다.

**앰비언트 컨텍스트**의 가장 큰 단점은 코드의 **잠재적인 문제**를 가리는 것이다. 로거를 **명시적**으로 주입하는 것이 불편해서 앰비언트 컨텍스트에 **의존**해야 한다면, 이는 **문제의 징후**이다. 어떤 경우라도 앰비언트 컨텍스트가 해결책은 아니다.

로거를 **명시적**으로 주입하는 한 가지 방법(**메서드 인수**)는 다음과 같다. 또 다른 방법은 **생성자**를 통해 하는 것이다.

```cs
// 명시적인 로거 주입

public void ChangEmail(
    string newEmail,
    Company company,
    ILogger logger)
```

## 8.7 결론

**식별할 수 있는 동작**인지, **구현 세부 사항**인지 여부에 대한 관점으로 **프로세스 외부 의존성**과의 통신을 살펴보자. 개발자가 아닌 사람이 로그를 **볼 수 있으면** 로깅 기능을 **목**으로 처리하고, 그렇지 않으면 **테스트하지 말라**.
