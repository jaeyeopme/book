# Chapter 3 - 단위 테스트 구조

## 3.1 단위 테스트를 구성하는 방법

### 3.1.1 AAA 패턴 사용

AAA 패턴은 Assert(준비), Act(실행), Assert(검증) 세 부분으로 나눠지며, 단순하고 균일한 구조를 갖는 데 도움을 준다.
가장 큰 장점은 일관성이며 유지 보수 비용이 줄어든다.

> Given-When-Then 패턴과 동일하지만, 상대적인 가독성이 떨어진다.

대부분 준비 구절로 시작하지만 _TDD_의 경우 검증 구절로 시작하여 기대하는 동작으로 윤곽을 잡은 후 기대에 부응하기 위한 고민을 하는 것이 좋다. 특정 동작의 목적을 생각하며 먼저 검증 구절을 작성하는 것은 단지 사고 과정의 형식이다.

### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

구절이 테스트에 너무 많은 경우 테스트를 나눠서 해결한다. 여러 개의 동작 단위를 검증하는 것은 통합 테스트이며, 일련의 실행과 검증을 포함한다면 리팩터링 해야한다. 각 동작을 고유 테스트로 도출해야한다.

여러 실행과 검증 구절을 하나의 단위로 묶는 것은 통합 테스트의 속도를 올리는 한 가지 방법으로 시스템 흐름상 **실행 구절**이 후속 **실행 구절**을 위한 **준비 구절**이 될 때 유용하다. 하지만 이미 느리고 더 느리게 하고 싶지 않은 통합 테스트 한정이며, 항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 좋다.

### 3.1.3 테스트 내 if 문 피하기

`if` 문이 있는 단위 테스트는 한번에 너무 많은 검증을 하기 때문에 분기로 인한 이점은 없고 추가 유지비만 상승하는 안티 패턴이다. 이는 통합 테스트에서도 동일하다.

### 3.1.4 각 구절은 얼마나 커야 하는가?

**준비 구절이 가장 큰 경우**

일반적으로 제일 커지기 쉽고, 실행과 검증 구절을 합친 것보다 크다면 같은 클래스 내 **private 메서드** 또는 **별도의 팩터리 클래스**를 만드는 것이 좋다. 재사용에 도움이 되는 패턴으로 `Object Mother` 와 `Test Data Builder` 패턴이 있다.

**실행 구절이 한 줄 이상인 경우를 경계하라**

실행 구절이 두 개 이상이라면 _SUT_ 의 **public API** 에 문제가 있을 수 있다. 테스트 자체는 문제가 없지만 실행 A를 마치려면 실행 B를 실행해야하기 때문에 의존하지 말아야 할 클라이언트에게 메서드 호출을 강요하게 된다. 이는 A를 호출하고 B를 호출하지 않았을 때 **불변 위반**이라는 모순이 생기는 것을 보호하기 위해 단일 public 메서드로 캡슐화 해야한다. 해결책은 항상 캡슐화를 지키는 것이며, 불변을 지키는 한 위반을 초래할 수 있는 잠재적인 행동은 제거해야 한다.

> SUT 란 System Unter Test 로 테스트 대상 시스템이다.

### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가

테스트당 하나당 검증 구절 하나는 올바르지 않다. 단위 테스트의 단위는 코드가 아닌 동작이기 때문에 여러 결과를 낼 수 있고, 검증 구절이 너무 커진다면 제품 코드에서 추상화의 누락이 있을 수 있다. 모든 속성이 아닌 추상화한 동등 멤버로 검증하는 것이 좋다.

### 3.1.6 종료 단계는 어떤가

테스트 이후 후 처리로 종료 구절을 따로 구분하기도 한다. 대부분의 단위 테스트에서는 필요 없으며, 통합 테스트의 영역이다.

### 3.1.7 테스트 대상 시스템 구별하기

동작은 여러 클래스에 걸쳐있을 수 있지만 동작을 수행할 클래스(진입점)은 하나여야 한다. SUT 와 의존성을 구분하는 것은 중요하며, SUT 가 많은 경우 인스턴스의 이름을 적절하게 바꿔 테스트 대상을 식별한다.

### 3.1.8 준비, 실행, 검증 주석 제거하기

각 구절은 주석이 아닌 빈 줄로 구분하는 것이 좋다. 하지만 대규모 테스트인 경우 많은 준비 또는 검증 구절 사이에 빈줄이 생길 수 있으며, 빈 줄로 구절을 구분할 수 없는 경우 주석을 유지하는 것이 좋다.

### 3.2 xUnit 테스트 프레임워크 살펴보기

`[Fact]` 특성은 테스트가 아닌 사실이라고 한다. 이는 '각 테스트는 이야기가 있어야 한다.' 는 점을 강조한다. 이야기는 문제 영역에 대한 개별적이고 원자적인 사실이나 시나리오이며, 통과하는 것은 이게 실제 사실이라는 증거이다. 실패하면 이야기는 유효하지 않아 다시 작성하거나 시스템을 수정해야 한다. 테스트는 제품 코드의 기능 나열이 아닌 비즈니스 담당자에게도 의미가 있는 동작에 대한 고수준의 명세가 있어야 한다.

## 3.3 테스트 간 테스트 픽스처 재사용

준비 구절의 코드를 재사용하는 것은 좋은 방법이다. 이러한 준비는 메서드나 별도의 클래스로 분리하는 것이 좋다.

> 테스트 픽스처란 테스트 실행 대상 객체이며, SUT 로 전달되는 인수이다. 각 테스트 실행 전 고정 상태를 유지하기 때문에 동일한 결과를 제공한다.

테스트 픽스처를 재사용하는 올바르지 않은 방법은 테스트 생성자에서 픽스처를 초기화하는 방법이다. 이는 가독성을 떨어뜨리고, 테스트간의 결합도를 높인다.

### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다

테스트 생성자에서 픽스처를 초기화하는 경우 준비 로직을 변경한다면 전체 테스트에 영향을 미치기 때문에 테스트 클래스에 공유 상태를 두지 말아야 한다. 독립적인 수정과 실행은 잘 설계된 테스트의 중요한 특성이다.

### 3.3.2 테스트 가동성을 떨어뜨리는 생성자 사용

준비 코드가 테스트에 없다면 큰 그림을 볼 수 없다. 독립적인 테스트는 불확실성을 두지 않기 때문에 테스트 픽스처의 인스턴스화만 있더라도 테스트 메서드로 바로 옮기는 것이 좋다. 

### 3.3.3 더 나은 테스트 픽스처 재사용법

private 팩터리 메서드로 추출해 코드를 짧게 하고, 진행 상황의 전체 맥락을 유지할 수 있다. 메서드를 충분히 일반화한다면 테스트가 서로 결합되지 않는다.

## 3.4 단위 테스트 명명법

`[테스트 대상 메서드]_[시나리오]_[예상 결과]` 는 가장 유명하지만 도움 되지 않는 방법이며, 동작 대신 구현 세부사항에 집중하게 부추긴다.

간단하고 쉬운 영어 구문이 효과적이며, 프로그래머 눈에는 도움 되지 않는 방법이 더 논리적으로 보이겠지만 가독성은 떨어지고 시간이 지날수록 정신적 부담과 테스트 스위트의 유지비가 늘어난다.

```cs
// 간결함
public void Sum_of_two_numbers()

// Sum? ReturnSum?
public void Sum_TwoNumbers_ReturnSum()
```

### 3.4.1 단위 테스트 명명 지침

* 표현의 자유를 허용하라. 엄격한 정책에 복잡한 동작에 대한 설명을 넣을 수 없다.
* 도메인이 익숙한 비개발자를 위한 이름을 지어라.
* snake_case 를 사용해 가독성을 향상 시켜라.
* `[클래스명]Test` 로 끝나는 테스트 클래스는 진입점이다. 단위 테스트의 단위는 클래스가 아닌 동작이다.

### 3.4.2 예제: 지침에 따른 테스트 이름 변경

코드가 아닌 동작을 테스트하는 것이기 때문에 SUT 는 단지 진입점이며, 호출 수단이다. 코드를 목표로 한다면 코드의 구현 세부사항과 테스트의 결합도가 높아진다.

```cs
// 1. 엄격한 정책의 테스트
IsDeliveryValid_InvalidDate_ReturnFalse()

// 2. SUT의 메서드명이 더 포함되지 않음
Delivery_with_invalid_date_should_be_considered_invalid()

// 3. 동작의 구체성
Delivery_with_past_date_should_be_considered_invalid()

// 4. 무의미한 단어 제거
Delivery_with_past_date_should_be_invalid()
```

`should be` 는 안티 패턴이다. 하나의 테스트는 동작 단위에 대한 단순하고 원자적인 사실이며, 사실에는 소망이나 욕구가 없다.

```cs
// 5. should be (안티패턴) 제거
Delevery_with_past_date_is_invalid()
```

사실에 대해 단도직입적인 설명이며, 동작의 관점 중 하나를 설명한다.

```cs
// 6. 영문법 준수
Delevery_with_a_past_date_is_invalid()
```

## 3.5 매개변수화된 테스트 리팩터링하기

보통 테스트 하나로 동작 단위를 설명하지 못한다. 동작이 복잡하면 테스트 수가 증가하고 관리하기 어려워진다. 매개변수화된 테스트를 사용하여 유사한 사실을 단일 테스트 메서드로 묶을 수 있다.

```cs
Delevery_for_today_is_invalid()
Delivery_for_tommorw_is_invalid()
The_sonnest_delivery_date_is_two_days_from_now()
```

세 가지 메서드의 유일한 차이점은 배송 날짜이다. 준비 값과 기대 값을 하나의 집합으로써 매개변수로 받는다. 각 테스트는 별도의 테스트가 아니므로 좀 더 일반적인 이름으로 바꿔야 한다. 

```cs
Can_detect_an_invalid_delivery_date()
```

매개변수화된 테스트를 하면 테스트 코드의 양을 줄일 수 있지만 비용이 발생한다. 이제 테스트 메서드의 이름으로 나타내는 사실을 파악하기 어렵고 매개변수가 많아질 수록 더 어려워진다.

검증 값이 `boolean` 인 경우 매개변수를 제거하여 부정 테스트를 단순하게 할 수 있다. 입력 매개변수로 케이스를 판단할 수 있다면 긍정, 부정 두 가지 케이스를 하나의 메서드로 도출하는 것이 저자 경험상 좋으며, 그렇지 않다면 긍정 케이스를 도출하고, 동작이 복잡하다면 긍정, 부정 케이스 모두 각각 고유의 메서드로 나타내야 한다.