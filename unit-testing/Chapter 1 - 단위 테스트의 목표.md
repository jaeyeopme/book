# Chapter 1 - 단위 테스트의 목표

단위 테스트에 시간을 투자할 때는 노력은 가능한 줄이며 이득을 최대화해야 한다. 단위 테스트를 많이 작성해도 많은 버그와 유지비로 진행은 느려진다.

## 1.1 단위 테스트 현황

기업용 애플리케이션은 거의 모두 자동화된 단위 테스트가 있고, 통합 테스트를 통해 좋은 커버리지를 달성하고 있다. 그러나 좋지 않은 테스트라면 새로운 기능 구현이 더 오래 걸리고, 새로운 버그가 나타나는 등 테스트가 오히려 상황을 더 나쁘게 할 수 있다. 논쟁은 '단위 테스트를 작성해야 하는가?' 에서 '좋은 단위 테스트를 작성하는 것은 어떤 의미인가?' 로 바뀌었다.

## 1.2 단위 테스트의 목표

코드를 테스트하기 어렵다면 개선이 반드시 필요하다는 것을 의미한다. 보통 **강결합**에서 저품질이 나타나지만 테스트가 쉽다고 해도 반드시 고품질은 아니다. 코드 설계는 단위 테스트의 목표가 아닌, 좋은 **부수 효과**일 뿐이다.

단위 테스트의 목표는 **지속 가능한 성장**을 가능하게 하는 것이다. 테스트가 없다면 시간이 지나면서 개발 속도는 현저히 느려지고, 코드베이스에서 코드를 변경할 때 지속적인 정리와 리팩터링 같은 관리를 하지 않는다면 **회귀**가 늘어나고, 더 이상 코드베이스를 신뢰할 수 없게 된다. 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공하기 때문에 코드베이스의 신뢰성을 높여준다.

> 회귀란 특정 사건 후에 기능이 의도한대로 동작하지 않는 경우를 말한다.

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

잘못 작성한 테스트와 전혀 없는 테스트는 거시적인 관점에서 큰 차이가 없다.

모든 테스트를 작성할 필요는 없다. 테스트를 더 많이 쏟아내도 **일부 중요한 테스트**를 제외한 나머지들은 프로젝트에 도움이 되는지를 파악하지 않고 테스트를 작성하는 데만 빠져들기 쉽다. 테스트의 **가치**와 **유지 비용**을 모두 고려해야 한다. 비용 요소를 살펴보자.

* 베이스코드를 리팩터링할 때 테스트도 같이 하라.
* 코드 변경 시 테스트를 실행하라.
* 테스트가 실패할 경우 처리하라.
* 베이스코드의 동작을 이해할 때 테스트를 읽는 데 시간을 투자하라.

지속 가능한 성장을 위해서는 **고품질 테스트**에만 집중해라. **코드는 자산이 아니라 책임이다**. 코드가 많아질 수록 버그에 노출되는 면적은 넓어지고 유지비가 증가한다. **가능한 적은 코드**로 문제를 해결하는 것이 좋다.

## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

가장 널리 사용되는 두 가지 커버리지 지표가 있다. 특정 커버리지 숫자를 목표로 하는 것은 해로우며, 테스트 스위트 품질을 결정할 때 커버리지 지표에 의존할 수 없다.

> 커버리지 지표란 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.

일반적으로 커버리지 숫자가 높을수록 더 좋지만, 품질을 측정하는 데 사용될 수 없다. 커버리지가 너무 적을 때는 테스트가 충분하지 않다는 것이지만, 반대의 경우는 반드시 양질의 테스트 스위트라고 보장되지 않는다.

### 1.3.1 코드 커버리지 지표에 대한 이해

라인 수만 처리하기 때문에 개선이 아닌 코드를 바꾸기만해도 커버리지는 100% 로 증가할 수 있다.

### 1.3.2 분기 커버리지 지표에 대한 이해

코드 라인 수를 사용하는 대신 `if` 문과 `switch` 문과 같은 제어 구조에 중점을 둔다. 코드 커버리지보다 더 정확한 결과를 제공하지만, 분기 개수만 다루기 때문에 분기를 구현하는 데 얼마나 코드가 필요한지 고려하지 않는다.

### 1.3.3 커버리지 지표에 관한 문제점

**가능한 모든 결과**를 검증한다고 보장할 수 없다. 실행하는지가 아닌 **시스템이 낸 결과**가 정확히 예상하는 결과인지 확인하는 적절한 검증이 필요하다. 커버리지 지표는 실행만 한다면 상황 검증이 전혀 없는 테스트도 커버리지에 포함한다.

외부 라이브러리의 코드 경로를 고려할 수 없다. 외부 라이브러리가 수행하는 코드 경로는 고려하지 않기 때문에 수많은 예외 상황에 빠질 수 있으며, 이는 커버리지 지표가 고려해야한다는 것이 아니라(**고려하면 안 된다.**) 해당 지표로 코드의 품질을 확인할 수 없다는 것이다.

### 1.3.4 특정 커버리지 숫자를 목표로 하기

테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾게 한다. 숫자를 **강요**하면 테스트 대상에 신경쓰지 못한다. 커버리지 숫자가 낮으면 문제 징후라 할 수 있지만 높은 숫자도 **별 의미 없다**.(핵심 부분은 요구 사항으로 삼는 것이 아니라면 높게 두는 것이 좋다.) 커버리지 측정은 성공적인 테스트 스위트를 위한 첫 걸음이다.

## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

테스트 스위트의 품질을 측정하는 방법은 각 테스트를 **하나씩 따로 평가**하는 것 뿐이다. 얼마나 좋은지 자동으로 확인할 수 없다. 성공적인 테스트 스위트의 특성을 살펴보자.

* 개발 주기에 통합돼 있다.
* 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
* 최소한의 유지비로 최대의 가치를 끌어낸다.

### 1.4.1 개발 주기에 통합돼 있음

자동화된 테스트는 끊임없이 하는것 뿐이며, 이상적으로는 코드가 변경될 때마다 작은 것이라도 실행해야 한다.

### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다. 가장 중요한 부분에 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다. 다른 부분을 살펴보자.

* 인프라 코드
* 데이터베이스나 서드파티와 같은 외부 서비스 및 종속성
* 퍼사드 코드

다른 부분에 복잡하고 중요한 알고리즘을 철저하게 테스트 해야할 수 있지만, 일반적으로 도메인 모델에 관심을 더 많이 갖는 것이 좋다. 통합 테스트와 같이 전체적인 작동을 테스트 하는 것도 괜찮다. 하지만 초점은 **도메인 모델**에 머물러야 하며, 이를 따르려면 도메인 모델을 **다른 애플리케이션 문제와 분리**해야 집중할 수 있다.

### 1.4.3 최소 유지비로 최대 가치를 끌어냄

가장 어려운 특성이며, 테스트를 빌드 시스템에 통합하는 것만으로 충분하지 않고, 도메인 모델에 높은 커버리지를 유지하는 것도 충분하지 않다. 가치가 **유지비를 상회하는** 테스트만 스위트에 유지하는 것이 중요하다. 이를 달성하기 위해 가치 있는 테스트를 **식별**하는 것은 중요하다.
