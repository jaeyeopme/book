# Chapter 1 - 단위 테스트의 목표

단위 테스트에 시간을 투자할 때는 항상 노력은 가능한 줄이며 이득을 최대화해야 한다. 단위 테스트에 노력을 많이 들여도 많은 버그와 유지비로 진행은 느려진다. 균형을 달성한 프로젝트는 유지보수가 많이 필요하지 않으며, 변화하는 요구에 신속히 대응할 수 있다.

## 1.1 단위 테스트 현황

단위 테스트를 적용해야 하는지는 더 이상 논쟁거리가 아니다. 기업용 애플리케이션은 거의 모두 자동화된 단위 테스트가 있고, 통합 테스트를 통해 좋은 커버리지를 달성하고 있다. 그러나 좋지 않은 테스트라면 새로운 기능 구현이 더 오래 걸리고, 새로운 버그가 나타나는 등 테스트가 오히려 상황을 더 나쁘게 할 수 있다. 논쟁은 '단위 테스트를 작성해야 하는가?' 에서 '좋은 단위 테스트를 작성하는 것은 어떤 의미인가?' 로 바뀌었다.

## 1.2 단위 테스트의 목표

코드를 테스트하기 어렵다면 개선이 반드시 필요하다는 것을 의미한다. 보통 강결합에서 저품질이 나타난다. 하지만 테스트가 쉽다고 해도 반드시 코드 품질이 좋은 것은 아니다. 코드 설계는 단위 테스트의 주된 목표가 아닌, 좋은 부수 효과일 뿐이다.

단위 테스트의 목표는 지속 가능한 성장을 가능하게 하는 것이다. 테스트가 없다면 시간이 지나면서 개발 속도는 현저히 느려지고, 코드베이스에서 코드를 변경할 때 지속적인 정리와 리팩터링 같은 관리를 하지 않는다면 **회귀**가 늘어나고, 더 이상 코드베이스를 신뢰할 수 없게 된다. 테스트는 안전망 역할을 하며, 대부분의 **회귀**에 대한 보험을 제공하기 때문에 코드베이스의 신뢰성을 높여준다.

> 회귀란 특정 사건 후에 기능이 의도한대로 동작하지 않는 경우를 말한다.

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

잘못 작성한 테스트는 프로젝트 성장에 큰 도움이 되지 않는다. 잘못 작성한 테스트와 전혀 없는 테스트는 거시적인 관점에서 큰 차이가 없다.

모든 테스트를 작성할 필요는 없다. 단지 테스트를 더 많이 쏟아내도 일부 중요한 테스트를 제외한 나머지들은 프로젝트에 도움이 되는지를 파악하지 않고 테스트를 작성하는 데만 빠져들기 쉽다. 테스트의 가치와 유지 비용을 모두 고려해야 한다.

**비용 요소**

* 베이스코드를 리팩터링할 때 테스트도 같이 하라.
* 코드 변경 시 테스트를 실행하라.
* 테스트가 실패할 경우 처리하라.
* 베이스코드의 동작을 이해할 때 테스트를 읽는 데 시간을 투자하라.

지속 가능한 성장을 위해서는 고품질 테스트에만 집중해라. 코드는 자산이 아니라 책임이다. 코드가 많아질 수록 버그에 노출되는 면적은 넓어지고 유지비가 증가한다. 애플리케이션의 정확성 보장을 목표로하여 가능한 적은 코드로 문제를 해결하는 것이 좋다.

## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

가장 널리 사용되는 두 가지 커버리지 지표가 있다. 특정 커버리지 숫자를 목표로 하는 것은 해로우며, 테스트 스위트 품질을 결정할 때 커버리지 지표에 의존할 수 없다.

> 커버리지 지표란 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.

일반적으로 커버리지 숫자가 높을수록 더 좋지만, 커버리지 지표는 중요한 피드백을 주더라도 품질을 측정하는 데 사용될 수 없다. 커버리지가 너무 적을 때는 테스트가 충분하지 않다는 것이지만, 반대의 경우는 반드시 양질의 테스트 스위트라고 보장되지 않는다.

### 1.3.1 코드 커버리지 지표에 대한 이해

라인 수만 처리하기 때문에 개선이 아닌 코드를 바꾸기만해도 커버리지는 100% 로 증가할 수 있다.

### 1.3.2 분기 커버리지 지표에 대한 이해

코드 라인 수를 사용하는 대신 `if` 문과 `switch` 문과 같은 제어 구조에 중점을 둔다. 
코드 커버리지보다 더 정확한 결과를 제공하지만, 분기 개수만 다루기 때문에 분기를 구현하는 데 얼마나 코드가 필요한지 고려하지 않는다. 

### 1.3.3 커버리지 지표에 관한 문제점

가능한 모든 결과를 검증한다고 보장할 수 없다. 실행하는지가 아닌 시스템이 낸 결과가 정확히 예상하는 결과인지 확인하는 적절한 검증이 필요하다. 커버리지 지표는 실행만 한다면 상황 검증이 전혀 없는 테스트도 커버리지에 포함한다.

외부 라이브러리의 코드 경로를 고려할 수 없다. 외부 라이브러리가 수행하는 코드 경로는 고려하지 않기 때문에 수많은 예외 상황에 빠질 수 있다. 이는 커버리지 지표가 고려해야한다는 것이 아니라(**고려하면 안 된다.**) 해당 지표로 코드의 품질을 확인할 수 없다는 것이다.

### 1.3.4 특정 커버리지 숫자를 목표로 하기

특정 커버리지 숫자를 목표로 하는 것은 중요한 것을 테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾게 한다. 숫자를 강요하면 테스트 대상에 신경쓰지 못한다. 커버리지 숫자가 낮으면 문제 징후라 할 수 있지만 높은 숫자도 별 의미 없다.(핵심 부분은 요구 사항으로 삼는 것이 아니라면 높게 두는 것이 좋다.) 커버리지 측정은 성공적인 테스트 스위트를 위한 첫걸음이다.

## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

테스트 스위트의 품질을 측정하는 방법은 각 테스트를 하나씩 따로 평가하는 것 뿐이다. 얼마나 좋은지 자동으로 확인할 수 없다.

**성공적인 테스트 스위트의 특성**

* 개발 주기에 통합돼 있다.
* 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
* 최소한의 유지비로 최대의 가치를 끌어낸다.

### 1.4.1 개발 주기에 통합돼 있음

자동화된 테스트는 끊임없이 하는것 뿐이며, 이상적으로는 코드가 변경될 때마다 작은 것이라도 실행해야 한다.

### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

가장 중요한 부분에 노력을 기울이고, _다른 부분_은 간략하게 또는 간접적으로 검증하는 것이 좋다.
비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.

**다른 부분**

* 인프라 코드
* 데이터베이스나 서드파티와 같은 외부 서비스 및 종속성
* 퍼사드 코드

다른 부분에 복잡하고 중요한 알고리즘을 철저하게 테스트 해야할 수 있지만, 일반적으로 도메인 모델에 관심을 더 많이 갖는 것이 좋다. 통합 테스트와 같이 전체적인 작동을 테스트 하는 것도 괜찮다. 하지만 초점은 도메인 모델에 머물러야 하며, 이를 따르려면 도메인 모델을 다른 애플리케이션 문제와 분리해야 집중할 수 있다. 

### 1.4.3 최소 유지비로 최대 가치를 끌어냄

가장 어려운 특성이며, 테스트를 빌드 시스템에 통합하는 것만으로 충분하지 않고, 도메인 모델에 높은 커버리지를 유지하는 것도 충분하지 않다. 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다. 이를 달성하기 위해 가치 있는 테스트를 식별하는 것은 중요하다.

단위 테스트와 코드베이스는 서로 얽혀 있으므로 코드베이스의 설계에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.
